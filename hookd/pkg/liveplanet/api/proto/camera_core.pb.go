// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: camera_core.proto

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		camera_core.proto

	It has these top-level messages:
		RTMPPoint
		Preview
		Output
		Encode
		Quality
		Point
		Picture
		Curve
		Notification
		AudioDevice
		AudioDevices
		Calibration
		Calibrations
		HDR
		Storage
		WifiNetwork
		Network
		Software
		FOV
		State
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type Preview_PreviewType int32

const (
	Preview_NONE   Preview_PreviewType = 0
	Preview_STEREO Preview_PreviewType = 1
	Preview_MONO   Preview_PreviewType = 2
)

var Preview_PreviewType_name = map[int32]string{
	0: "NONE",
	1: "STEREO",
	2: "MONO",
}
var Preview_PreviewType_value = map[string]int32{
	"NONE":   0,
	"STEREO": 1,
	"MONO":   2,
}

func (x Preview_PreviewType) String() string {
	return proto1.EnumName(Preview_PreviewType_name, int32(x))
}
func (Preview_PreviewType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCameraCore, []int{1, 0}
}

type Output_OutputType int32

const (
	Output_OFF         Output_OutputType = 0
	Output_HLS         Output_OutputType = 1
	Output_FILE        Output_OutputType = 2
	Output_RTMP        Output_OutputType = 3
	Output_RTMP_CUSTOM Output_OutputType = 4
)

var Output_OutputType_name = map[int32]string{
	0: "OFF",
	1: "HLS",
	2: "FILE",
	3: "RTMP",
	4: "RTMP_CUSTOM",
}
var Output_OutputType_value = map[string]int32{
	"OFF":         0,
	"HLS":         1,
	"FILE":        2,
	"RTMP":        3,
	"RTMP_CUSTOM": 4,
}

func (x Output_OutputType) String() string {
	return proto1.EnumName(Output_OutputType_name, int32(x))
}
func (Output_OutputType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCameraCore, []int{2, 0}
}

type Quality_QualityType int32

const (
	Quality_NONE   Quality_QualityType = 0
	Quality_LOW    Quality_QualityType = 1
	Quality_MEDIUM Quality_QualityType = 2
	Quality_HIGH   Quality_QualityType = 3
	Quality_ULTRA  Quality_QualityType = 4
)

var Quality_QualityType_name = map[int32]string{
	0: "NONE",
	1: "LOW",
	2: "MEDIUM",
	3: "HIGH",
	4: "ULTRA",
}
var Quality_QualityType_value = map[string]int32{
	"NONE":   0,
	"LOW":    1,
	"MEDIUM": 2,
	"HIGH":   3,
	"ULTRA":  4,
}

func (x Quality_QualityType) String() string {
	return proto1.EnumName(Quality_QualityType_name, int32(x))
}
func (Quality_QualityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCameraCore, []int{4, 0}
}

type Notification_NotificationType int32

const (
	Notification_NONE                Notification_NotificationType = 0
	Notification_SUCCESS             Notification_NotificationType = 1
	Notification_ERROR               Notification_NotificationType = 2
	Notification_WARNING             Notification_NotificationType = 3
	Notification_CALIBRATION_SUCCESS Notification_NotificationType = 4
	Notification_CALIBRATION_FAILED  Notification_NotificationType = 5
	Notification_AUDIO_CHANGE        Notification_NotificationType = 6
	Notification_BUTTON_RECORD_FILE  Notification_NotificationType = 7
	Notification_BUTTON_SHUTDOWN     Notification_NotificationType = 8
)

var Notification_NotificationType_name = map[int32]string{
	0: "NONE",
	1: "SUCCESS",
	2: "ERROR",
	3: "WARNING",
	4: "CALIBRATION_SUCCESS",
	5: "CALIBRATION_FAILED",
	6: "AUDIO_CHANGE",
	7: "BUTTON_RECORD_FILE",
	8: "BUTTON_SHUTDOWN",
}
var Notification_NotificationType_value = map[string]int32{
	"NONE":                0,
	"SUCCESS":             1,
	"ERROR":               2,
	"WARNING":             3,
	"CALIBRATION_SUCCESS": 4,
	"CALIBRATION_FAILED":  5,
	"AUDIO_CHANGE":        6,
	"BUTTON_RECORD_FILE":  7,
	"BUTTON_SHUTDOWN":     8,
}

func (x Notification_NotificationType) String() string {
	return proto1.EnumName(Notification_NotificationType_name, int32(x))
}
func (Notification_NotificationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCameraCore, []int{8, 0}
}

type HDR_HDRType int32

const (
	HDR_OFF  HDR_HDRType = 0
	HDR_ON   HDR_HDRType = 1
	HDR_AUTO HDR_HDRType = 2
)

var HDR_HDRType_name = map[int32]string{
	0: "OFF",
	1: "ON",
	2: "AUTO",
}
var HDR_HDRType_value = map[string]int32{
	"OFF":  0,
	"ON":   1,
	"AUTO": 2,
}

func (x HDR_HDRType) String() string {
	return proto1.EnumName(HDR_HDRType_name, int32(x))
}
func (HDR_HDRType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{13, 0} }

type FOV_FOVMode int32

const (
	FOV_FOV_MODE_360 FOV_FOVMode = 0
	FOV_FOV_MODE_180 FOV_FOVMode = 1
)

var FOV_FOVMode_name = map[int32]string{
	0: "FOV_MODE_360",
	1: "FOV_MODE_180",
}
var FOV_FOVMode_value = map[string]int32{
	"FOV_MODE_360": 0,
	"FOV_MODE_180": 1,
}

func (x FOV_FOVMode) String() string {
	return proto1.EnumName(FOV_FOVMode_name, int32(x))
}
func (FOV_FOVMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{18, 0} }

type RTMPPoint struct {
	RtmpAddress  string `protobuf:"bytes,1,opt,name=rtmp_address,json=rtmpAddress,proto3" json:"rtmp_address,omitempty"`
	RtmpsAddress string `protobuf:"bytes,2,opt,name=rtmps_address,json=rtmpsAddress,proto3" json:"rtmps_address,omitempty"`
}

func (m *RTMPPoint) Reset()                    { *m = RTMPPoint{} }
func (m *RTMPPoint) String() string            { return proto1.CompactTextString(m) }
func (*RTMPPoint) ProtoMessage()               {}
func (*RTMPPoint) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{0} }

func (m *RTMPPoint) GetRtmpAddress() string {
	if m != nil {
		return m.RtmpAddress
	}
	return ""
}

func (m *RTMPPoint) GetRtmpsAddress() string {
	if m != nil {
		return m.RtmpsAddress
	}
	return ""
}

type Preview struct {
	Type Preview_PreviewType `protobuf:"varint,1,opt,name=type,proto3,enum=proto.Preview_PreviewType" json:"type,omitempty"`
}

func (m *Preview) Reset()                    { *m = Preview{} }
func (m *Preview) String() string            { return proto1.CompactTextString(m) }
func (*Preview) ProtoMessage()               {}
func (*Preview) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{1} }

func (m *Preview) GetType() Preview_PreviewType {
	if m != nil {
		return m.Type
	}
	return Preview_NONE
}

type Output struct {
	Type           Output_OutputType `protobuf:"varint,1,opt,name=type,proto3,enum=proto.Output_OutputType" json:"type,omitempty"`
	Primary        *RTMPPoint        `protobuf:"bytes,2,opt,name=primary" json:"primary,omitempty"`
	Secondary      *RTMPPoint        `protobuf:"bytes,3,opt,name=secondary" json:"secondary,omitempty"`
	StartTimestamp int64             `protobuf:"varint,8,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
}

func (m *Output) Reset()                    { *m = Output{} }
func (m *Output) String() string            { return proto1.CompactTextString(m) }
func (*Output) ProtoMessage()               {}
func (*Output) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{2} }

func (m *Output) GetType() Output_OutputType {
	if m != nil {
		return m.Type
	}
	return Output_OFF
}

func (m *Output) GetPrimary() *RTMPPoint {
	if m != nil {
		return m.Primary
	}
	return nil
}

func (m *Output) GetSecondary() *RTMPPoint {
	if m != nil {
		return m.Secondary
	}
	return nil
}

func (m *Output) GetStartTimestamp() int64 {
	if m != nil {
		return m.StartTimestamp
	}
	return 0
}

type Encode struct {
	Framerate uint32 `protobuf:"varint,1,opt,name=framerate,proto3" json:"framerate,omitempty"`
	Bitrate   uint32 `protobuf:"varint,2,opt,name=bitrate,proto3" json:"bitrate,omitempty"`
}

func (m *Encode) Reset()                    { *m = Encode{} }
func (m *Encode) String() string            { return proto1.CompactTextString(m) }
func (*Encode) ProtoMessage()               {}
func (*Encode) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{3} }

func (m *Encode) GetFramerate() uint32 {
	if m != nil {
		return m.Framerate
	}
	return 0
}

func (m *Encode) GetBitrate() uint32 {
	if m != nil {
		return m.Bitrate
	}
	return 0
}

type Quality struct {
	Type Quality_QualityType `protobuf:"varint,1,opt,name=type,proto3,enum=proto.Quality_QualityType" json:"type,omitempty"`
}

func (m *Quality) Reset()                    { *m = Quality{} }
func (m *Quality) String() string            { return proto1.CompactTextString(m) }
func (*Quality) ProtoMessage()               {}
func (*Quality) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{4} }

func (m *Quality) GetType() Quality_QualityType {
	if m != nil {
		return m.Type
	}
	return Quality_NONE
}

type Point struct {
	X float64 `protobuf:"fixed64,1,opt,name=x,proto3" json:"x,omitempty"`
	Y float64 `protobuf:"fixed64,2,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *Point) Reset()                    { *m = Point{} }
func (m *Point) String() string            { return proto1.CompactTextString(m) }
func (*Point) ProtoMessage()               {}
func (*Point) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{5} }

func (m *Point) GetX() float64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Point) GetY() float64 {
	if m != nil {
		return m.Y
	}
	return 0
}

type Picture struct {
	Exposure    float64 `protobuf:"fixed64,1,opt,name=exposure,proto3" json:"exposure,omitempty"`
	Shadows     float64 `protobuf:"fixed64,2,opt,name=shadows,proto3" json:"shadows,omitempty"`
	Temperature float64 `protobuf:"fixed64,3,opt,name=temperature,proto3" json:"temperature,omitempty"`
	Tint        float64 `protobuf:"fixed64,4,opt,name=tint,proto3" json:"tint,omitempty"`
	Saturation  float64 `protobuf:"fixed64,5,opt,name=saturation,proto3" json:"saturation,omitempty"`
}

func (m *Picture) Reset()                    { *m = Picture{} }
func (m *Picture) String() string            { return proto1.CompactTextString(m) }
func (*Picture) ProtoMessage()               {}
func (*Picture) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{6} }

func (m *Picture) GetExposure() float64 {
	if m != nil {
		return m.Exposure
	}
	return 0
}

func (m *Picture) GetShadows() float64 {
	if m != nil {
		return m.Shadows
	}
	return 0
}

func (m *Picture) GetTemperature() float64 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func (m *Picture) GetTint() float64 {
	if m != nil {
		return m.Tint
	}
	return 0
}

func (m *Picture) GetSaturation() float64 {
	if m != nil {
		return m.Saturation
	}
	return 0
}

type Curve struct {
	Values []float64 `protobuf:"fixed64,1,rep,packed,name=values" json:"values,omitempty"`
	Cps    []*Point  `protobuf:"bytes,2,rep,name=cps" json:"cps,omitempty"`
}

func (m *Curve) Reset()                    { *m = Curve{} }
func (m *Curve) String() string            { return proto1.CompactTextString(m) }
func (*Curve) ProtoMessage()               {}
func (*Curve) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{7} }

func (m *Curve) GetValues() []float64 {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *Curve) GetCps() []*Point {
	if m != nil {
		return m.Cps
	}
	return nil
}

type Notification struct {
	Text      string                        `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Timestamp uint32                        `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Type      Notification_NotificationType `protobuf:"varint,3,opt,name=type,proto3,enum=proto.Notification_NotificationType" json:"type,omitempty"`
}

func (m *Notification) Reset()                    { *m = Notification{} }
func (m *Notification) String() string            { return proto1.CompactTextString(m) }
func (*Notification) ProtoMessage()               {}
func (*Notification) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{8} }

func (m *Notification) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Notification) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Notification) GetType() Notification_NotificationType {
	if m != nil {
		return m.Type
	}
	return Notification_NONE
}

type AudioDevice struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *AudioDevice) Reset()                    { *m = AudioDevice{} }
func (m *AudioDevice) String() string            { return proto1.CompactTextString(m) }
func (*AudioDevice) ProtoMessage()               {}
func (*AudioDevice) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{9} }

func (m *AudioDevice) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type AudioDevices struct {
	Devices     []*AudioDevice `protobuf:"bytes,1,rep,name=devices" json:"devices,omitempty"`
	ActiveIndex uint32         `protobuf:"varint,2,opt,name=active_index,json=activeIndex,proto3" json:"active_index,omitempty"`
}

func (m *AudioDevices) Reset()                    { *m = AudioDevices{} }
func (m *AudioDevices) String() string            { return proto1.CompactTextString(m) }
func (*AudioDevices) ProtoMessage()               {}
func (*AudioDevices) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{10} }

func (m *AudioDevices) GetDevices() []*AudioDevice {
	if m != nil {
		return m.Devices
	}
	return nil
}

func (m *AudioDevices) GetActiveIndex() uint32 {
	if m != nil {
		return m.ActiveIndex
	}
	return 0
}

type Calibration struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Calibration) Reset()                    { *m = Calibration{} }
func (m *Calibration) String() string            { return proto1.CompactTextString(m) }
func (*Calibration) ProtoMessage()               {}
func (*Calibration) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{11} }

func (m *Calibration) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Calibrations struct {
	Calibrations []*Calibration `protobuf:"bytes,1,rep,name=calibrations" json:"calibrations,omitempty"`
	ActiveIndex  uint32         `protobuf:"varint,2,opt,name=active_index,json=activeIndex,proto3" json:"active_index,omitempty"`
}

func (m *Calibrations) Reset()                    { *m = Calibrations{} }
func (m *Calibrations) String() string            { return proto1.CompactTextString(m) }
func (*Calibrations) ProtoMessage()               {}
func (*Calibrations) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{12} }

func (m *Calibrations) GetCalibrations() []*Calibration {
	if m != nil {
		return m.Calibrations
	}
	return nil
}

func (m *Calibrations) GetActiveIndex() uint32 {
	if m != nil {
		return m.ActiveIndex
	}
	return 0
}

type HDR struct {
	Type HDR_HDRType `protobuf:"varint,1,opt,name=type,proto3,enum=proto.HDR_HDRType" json:"type,omitempty"`
}

func (m *HDR) Reset()                    { *m = HDR{} }
func (m *HDR) String() string            { return proto1.CompactTextString(m) }
func (*HDR) ProtoMessage()               {}
func (*HDR) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{13} }

func (m *HDR) GetType() HDR_HDRType {
	if m != nil {
		return m.Type
	}
	return HDR_OFF
}

type Storage struct {
	IsMounted bool   `protobuf:"varint,1,opt,name=is_mounted,json=isMounted,proto3" json:"is_mounted,omitempty"`
	Total     uint64 `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	Used      uint64 `protobuf:"varint,3,opt,name=used,proto3" json:"used,omitempty"`
}

func (m *Storage) Reset()                    { *m = Storage{} }
func (m *Storage) String() string            { return proto1.CompactTextString(m) }
func (*Storage) ProtoMessage()               {}
func (*Storage) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{14} }

func (m *Storage) GetIsMounted() bool {
	if m != nil {
		return m.IsMounted
	}
	return false
}

func (m *Storage) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *Storage) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

type WifiNetwork struct {
	Ssid     string `protobuf:"bytes,1,opt,name=ssid,proto3" json:"ssid,omitempty"`
	Signal   string `protobuf:"bytes,2,opt,name=signal,proto3" json:"signal,omitempty"`
	Security string `protobuf:"bytes,3,opt,name=security,proto3" json:"security,omitempty"`
	IsActive bool   `protobuf:"varint,4,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
}

func (m *WifiNetwork) Reset()                    { *m = WifiNetwork{} }
func (m *WifiNetwork) String() string            { return proto1.CompactTextString(m) }
func (*WifiNetwork) ProtoMessage()               {}
func (*WifiNetwork) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{15} }

func (m *WifiNetwork) GetSsid() string {
	if m != nil {
		return m.Ssid
	}
	return ""
}

func (m *WifiNetwork) GetSignal() string {
	if m != nil {
		return m.Signal
	}
	return ""
}

func (m *WifiNetwork) GetSecurity() string {
	if m != nil {
		return m.Security
	}
	return ""
}

func (m *WifiNetwork) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

type Network struct {
	EthConnected bool           `protobuf:"varint,1,opt,name=eth_connected,json=ethConnected,proto3" json:"eth_connected,omitempty"`
	WifiNetworks []*WifiNetwork `protobuf:"bytes,4,rep,name=wifi_networks,json=wifiNetworks" json:"wifi_networks,omitempty"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto1.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{16} }

func (m *Network) GetEthConnected() bool {
	if m != nil {
		return m.EthConnected
	}
	return false
}

func (m *Network) GetWifiNetworks() []*WifiNetwork {
	if m != nil {
		return m.WifiNetworks
	}
	return nil
}

type Software struct {
	Installed string `protobuf:"bytes,1,opt,name=installed,proto3" json:"installed,omitempty"`
	Candidate string `protobuf:"bytes,2,opt,name=candidate,proto3" json:"candidate,omitempty"`
}

func (m *Software) Reset()                    { *m = Software{} }
func (m *Software) String() string            { return proto1.CompactTextString(m) }
func (*Software) ProtoMessage()               {}
func (*Software) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{17} }

func (m *Software) GetInstalled() string {
	if m != nil {
		return m.Installed
	}
	return ""
}

func (m *Software) GetCandidate() string {
	if m != nil {
		return m.Candidate
	}
	return ""
}

type FOV struct {
	Mode   FOV_FOVMode `protobuf:"varint,1,opt,name=mode,proto3,enum=proto.FOV_FOVMode" json:"mode,omitempty"`
	Offset uint32      `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (m *FOV) Reset()                    { *m = FOV{} }
func (m *FOV) String() string            { return proto1.CompactTextString(m) }
func (*FOV) ProtoMessage()               {}
func (*FOV) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{18} }

func (m *FOV) GetMode() FOV_FOVMode {
	if m != nil {
		return m.Mode
	}
	return FOV_FOV_MODE_360
}

func (m *FOV) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type State struct {
	Preview      *Preview      `protobuf:"bytes,1,opt,name=preview" json:"preview,omitempty"`
	Output       *Output       `protobuf:"bytes,2,opt,name=output" json:"output,omitempty"`
	Encode       *Encode       `protobuf:"bytes,3,opt,name=encode" json:"encode,omitempty"`
	Picture      *Picture      `protobuf:"bytes,4,opt,name=picture" json:"picture,omitempty"`
	Curve        *Curve        `protobuf:"bytes,5,opt,name=curve" json:"curve,omitempty"`
	Notification *Notification `protobuf:"bytes,6,opt,name=notification" json:"notification,omitempty"`
	Hdr          *HDR          `protobuf:"bytes,7,opt,name=hdr" json:"hdr,omitempty"`
	Storage      *Storage      `protobuf:"bytes,8,opt,name=storage" json:"storage,omitempty"`
	Network      *Network      `protobuf:"bytes,9,opt,name=network" json:"network,omitempty"`
	AudioDevices *AudioDevices `protobuf:"bytes,10,opt,name=audio_devices,json=audioDevices" json:"audio_devices,omitempty"`
	Software     *Software     `protobuf:"bytes,11,opt,name=software" json:"software,omitempty"`
	Calibrations *Calibrations `protobuf:"bytes,12,opt,name=calibrations" json:"calibrations,omitempty"`
	Fov          *FOV          `protobuf:"bytes,13,opt,name=fov" json:"fov,omitempty"`
	Quality      *Quality      `protobuf:"bytes,14,opt,name=quality" json:"quality,omitempty"`
}

func (m *State) Reset()                    { *m = State{} }
func (m *State) String() string            { return proto1.CompactTextString(m) }
func (*State) ProtoMessage()               {}
func (*State) Descriptor() ([]byte, []int) { return fileDescriptorCameraCore, []int{19} }

func (m *State) GetPreview() *Preview {
	if m != nil {
		return m.Preview
	}
	return nil
}

func (m *State) GetOutput() *Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *State) GetEncode() *Encode {
	if m != nil {
		return m.Encode
	}
	return nil
}

func (m *State) GetPicture() *Picture {
	if m != nil {
		return m.Picture
	}
	return nil
}

func (m *State) GetCurve() *Curve {
	if m != nil {
		return m.Curve
	}
	return nil
}

func (m *State) GetNotification() *Notification {
	if m != nil {
		return m.Notification
	}
	return nil
}

func (m *State) GetHdr() *HDR {
	if m != nil {
		return m.Hdr
	}
	return nil
}

func (m *State) GetStorage() *Storage {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *State) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *State) GetAudioDevices() *AudioDevices {
	if m != nil {
		return m.AudioDevices
	}
	return nil
}

func (m *State) GetSoftware() *Software {
	if m != nil {
		return m.Software
	}
	return nil
}

func (m *State) GetCalibrations() *Calibrations {
	if m != nil {
		return m.Calibrations
	}
	return nil
}

func (m *State) GetFov() *FOV {
	if m != nil {
		return m.Fov
	}
	return nil
}

func (m *State) GetQuality() *Quality {
	if m != nil {
		return m.Quality
	}
	return nil
}

func init() {
	proto1.RegisterType((*RTMPPoint)(nil), "proto.RTMPPoint")
	proto1.RegisterType((*Preview)(nil), "proto.Preview")
	proto1.RegisterType((*Output)(nil), "proto.Output")
	proto1.RegisterType((*Encode)(nil), "proto.Encode")
	proto1.RegisterType((*Quality)(nil), "proto.Quality")
	proto1.RegisterType((*Point)(nil), "proto.Point")
	proto1.RegisterType((*Picture)(nil), "proto.Picture")
	proto1.RegisterType((*Curve)(nil), "proto.Curve")
	proto1.RegisterType((*Notification)(nil), "proto.Notification")
	proto1.RegisterType((*AudioDevice)(nil), "proto.AudioDevice")
	proto1.RegisterType((*AudioDevices)(nil), "proto.AudioDevices")
	proto1.RegisterType((*Calibration)(nil), "proto.Calibration")
	proto1.RegisterType((*Calibrations)(nil), "proto.Calibrations")
	proto1.RegisterType((*HDR)(nil), "proto.HDR")
	proto1.RegisterType((*Storage)(nil), "proto.Storage")
	proto1.RegisterType((*WifiNetwork)(nil), "proto.WifiNetwork")
	proto1.RegisterType((*Network)(nil), "proto.Network")
	proto1.RegisterType((*Software)(nil), "proto.Software")
	proto1.RegisterType((*FOV)(nil), "proto.FOV")
	proto1.RegisterType((*State)(nil), "proto.State")
	proto1.RegisterEnum("proto.Preview_PreviewType", Preview_PreviewType_name, Preview_PreviewType_value)
	proto1.RegisterEnum("proto.Output_OutputType", Output_OutputType_name, Output_OutputType_value)
	proto1.RegisterEnum("proto.Quality_QualityType", Quality_QualityType_name, Quality_QualityType_value)
	proto1.RegisterEnum("proto.Notification_NotificationType", Notification_NotificationType_name, Notification_NotificationType_value)
	proto1.RegisterEnum("proto.HDR_HDRType", HDR_HDRType_name, HDR_HDRType_value)
	proto1.RegisterEnum("proto.FOV_FOVMode", FOV_FOVMode_name, FOV_FOVMode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CameraCoreService service

type CameraCoreServiceClient interface {
	GetState(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*State, error)
	SetPreview(ctx context.Context, in *Preview, opts ...grpc.CallOption) (*Preview, error)
	SetOutput(ctx context.Context, in *Output, opts ...grpc.CallOption) (*Output, error)
	SetEncode(ctx context.Context, in *Encode, opts ...grpc.CallOption) (*Encode, error)
	SetQuality(ctx context.Context, in *Quality, opts ...grpc.CallOption) (*Quality, error)
	SetPicture(ctx context.Context, in *Picture, opts ...grpc.CallOption) (*Picture, error)
	ResetPicture(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*Picture, error)
	SetCurve(ctx context.Context, in *Curve, opts ...grpc.CallOption) (*Curve, error)
	SetStorage(ctx context.Context, in *Storage, opts ...grpc.CallOption) (*Storage, error)
	SetHDR(ctx context.Context, in *HDR, opts ...grpc.CallOption) (*HDR, error)
	SetFOV(ctx context.Context, in *FOV, opts ...grpc.CallOption) (*FOV, error)
	SetSoftware(ctx context.Context, in *Software, opts ...grpc.CallOption) (*Software, error)
	NotificationStreaming(ctx context.Context, opts ...grpc.CallOption) (CameraCoreService_NotificationStreamingClient, error)
	Calibrate(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	GetCalibrations(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*Calibrations, error)
	SetCalibration(ctx context.Context, in *Calibration, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	SetDefaultCalibration(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	SaveCalibration(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*Calibration, error)
	GetAudioDevices(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*AudioDevices, error)
	SetAudioDevice(ctx context.Context, in *AudioDevice, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	Mount(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	Unmount(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	Shutdown(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}

type cameraCoreServiceClient struct {
	cc *grpc.ClientConn
}

func NewCameraCoreServiceClient(cc *grpc.ClientConn) CameraCoreServiceClient {
	return &cameraCoreServiceClient{cc}
}

func (c *cameraCoreServiceClient) GetState(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*State, error) {
	out := new(State)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/GetState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetPreview(ctx context.Context, in *Preview, opts ...grpc.CallOption) (*Preview, error) {
	out := new(Preview)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetPreview", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetOutput(ctx context.Context, in *Output, opts ...grpc.CallOption) (*Output, error) {
	out := new(Output)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetOutput", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetEncode(ctx context.Context, in *Encode, opts ...grpc.CallOption) (*Encode, error) {
	out := new(Encode)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetEncode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetQuality(ctx context.Context, in *Quality, opts ...grpc.CallOption) (*Quality, error) {
	out := new(Quality)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetQuality", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetPicture(ctx context.Context, in *Picture, opts ...grpc.CallOption) (*Picture, error) {
	out := new(Picture)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetPicture", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) ResetPicture(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*Picture, error) {
	out := new(Picture)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/ResetPicture", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetCurve(ctx context.Context, in *Curve, opts ...grpc.CallOption) (*Curve, error) {
	out := new(Curve)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetCurve", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetStorage(ctx context.Context, in *Storage, opts ...grpc.CallOption) (*Storage, error) {
	out := new(Storage)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetStorage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetHDR(ctx context.Context, in *HDR, opts ...grpc.CallOption) (*HDR, error) {
	out := new(HDR)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetHDR", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetFOV(ctx context.Context, in *FOV, opts ...grpc.CallOption) (*FOV, error) {
	out := new(FOV)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetFOV", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetSoftware(ctx context.Context, in *Software, opts ...grpc.CallOption) (*Software, error) {
	out := new(Software)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetSoftware", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) NotificationStreaming(ctx context.Context, opts ...grpc.CallOption) (CameraCoreService_NotificationStreamingClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CameraCoreService_serviceDesc.Streams[0], c.cc, "/proto.CameraCoreService/NotificationStreaming", opts...)
	if err != nil {
		return nil, err
	}
	x := &cameraCoreServiceNotificationStreamingClient{stream}
	return x, nil
}

type CameraCoreService_NotificationStreamingClient interface {
	Send(*google_protobuf.Empty) error
	Recv() (*Notification, error)
	grpc.ClientStream
}

type cameraCoreServiceNotificationStreamingClient struct {
	grpc.ClientStream
}

func (x *cameraCoreServiceNotificationStreamingClient) Send(m *google_protobuf.Empty) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cameraCoreServiceNotificationStreamingClient) Recv() (*Notification, error) {
	m := new(Notification)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cameraCoreServiceClient) Calibrate(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/Calibrate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) GetCalibrations(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*Calibrations, error) {
	out := new(Calibrations)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/GetCalibrations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetCalibration(ctx context.Context, in *Calibration, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetCalibration", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetDefaultCalibration(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetDefaultCalibration", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SaveCalibration(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*Calibration, error) {
	out := new(Calibration)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SaveCalibration", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) GetAudioDevices(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*AudioDevices, error) {
	out := new(AudioDevices)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/GetAudioDevices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) SetAudioDevice(ctx context.Context, in *AudioDevice, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/SetAudioDevice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) Mount(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/Mount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) Unmount(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/Unmount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cameraCoreServiceClient) Shutdown(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/proto.CameraCoreService/Shutdown", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CameraCoreService service

type CameraCoreServiceServer interface {
	GetState(context.Context, *google_protobuf.Empty) (*State, error)
	SetPreview(context.Context, *Preview) (*Preview, error)
	SetOutput(context.Context, *Output) (*Output, error)
	SetEncode(context.Context, *Encode) (*Encode, error)
	SetQuality(context.Context, *Quality) (*Quality, error)
	SetPicture(context.Context, *Picture) (*Picture, error)
	ResetPicture(context.Context, *google_protobuf.Empty) (*Picture, error)
	SetCurve(context.Context, *Curve) (*Curve, error)
	SetStorage(context.Context, *Storage) (*Storage, error)
	SetHDR(context.Context, *HDR) (*HDR, error)
	SetFOV(context.Context, *FOV) (*FOV, error)
	SetSoftware(context.Context, *Software) (*Software, error)
	NotificationStreaming(CameraCoreService_NotificationStreamingServer) error
	Calibrate(context.Context, *google_protobuf.Empty) (*google_protobuf.Empty, error)
	GetCalibrations(context.Context, *google_protobuf.Empty) (*Calibrations, error)
	SetCalibration(context.Context, *Calibration) (*google_protobuf.Empty, error)
	SetDefaultCalibration(context.Context, *google_protobuf.Empty) (*google_protobuf.Empty, error)
	SaveCalibration(context.Context, *google_protobuf.Empty) (*Calibration, error)
	GetAudioDevices(context.Context, *google_protobuf.Empty) (*AudioDevices, error)
	SetAudioDevice(context.Context, *AudioDevice) (*google_protobuf.Empty, error)
	Mount(context.Context, *google_protobuf.Empty) (*google_protobuf.Empty, error)
	Unmount(context.Context, *google_protobuf.Empty) (*google_protobuf.Empty, error)
	Shutdown(context.Context, *google_protobuf.Empty) (*google_protobuf.Empty, error)
}

func RegisterCameraCoreServiceServer(s *grpc.Server, srv CameraCoreServiceServer) {
	s.RegisterService(&_CameraCoreService_serviceDesc, srv)
}

func _CameraCoreService_GetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).GetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/GetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).GetState(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetPreview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Preview)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetPreview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetPreview",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetPreview(ctx, req.(*Preview))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Output)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetOutput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetOutput(ctx, req.(*Output))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetEncode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Encode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetEncode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetEncode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetEncode(ctx, req.(*Encode))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetQuality_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Quality)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetQuality(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetQuality",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetQuality(ctx, req.(*Quality))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetPicture_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Picture)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetPicture(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetPicture",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetPicture(ctx, req.(*Picture))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_ResetPicture_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).ResetPicture(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/ResetPicture",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).ResetPicture(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetCurve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Curve)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetCurve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetCurve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetCurve(ctx, req.(*Curve))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Storage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetStorage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetStorage(ctx, req.(*Storage))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetHDR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HDR)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetHDR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetHDR",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetHDR(ctx, req.(*HDR))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetFOV_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FOV)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetFOV(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetFOV",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetFOV(ctx, req.(*FOV))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetSoftware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Software)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetSoftware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetSoftware",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetSoftware(ctx, req.(*Software))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_NotificationStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CameraCoreServiceServer).NotificationStreaming(&cameraCoreServiceNotificationStreamingServer{stream})
}

type CameraCoreService_NotificationStreamingServer interface {
	Send(*Notification) error
	Recv() (*google_protobuf.Empty, error)
	grpc.ServerStream
}

type cameraCoreServiceNotificationStreamingServer struct {
	grpc.ServerStream
}

func (x *cameraCoreServiceNotificationStreamingServer) Send(m *Notification) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cameraCoreServiceNotificationStreamingServer) Recv() (*google_protobuf.Empty, error) {
	m := new(google_protobuf.Empty)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CameraCoreService_Calibrate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).Calibrate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/Calibrate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).Calibrate(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_GetCalibrations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).GetCalibrations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/GetCalibrations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).GetCalibrations(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetCalibration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Calibration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetCalibration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetCalibration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetCalibration(ctx, req.(*Calibration))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetDefaultCalibration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetDefaultCalibration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetDefaultCalibration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetDefaultCalibration(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SaveCalibration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SaveCalibration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SaveCalibration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SaveCalibration(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_GetAudioDevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).GetAudioDevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/GetAudioDevices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).GetAudioDevices(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_SetAudioDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AudioDevice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).SetAudioDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/SetAudioDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).SetAudioDevice(ctx, req.(*AudioDevice))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_Mount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).Mount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/Mount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).Mount(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_Unmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).Unmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/Unmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).Unmount(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CameraCoreService_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CameraCoreServiceServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.CameraCoreService/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CameraCoreServiceServer).Shutdown(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _CameraCoreService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.CameraCoreService",
	HandlerType: (*CameraCoreServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetState",
			Handler:    _CameraCoreService_GetState_Handler,
		},
		{
			MethodName: "SetPreview",
			Handler:    _CameraCoreService_SetPreview_Handler,
		},
		{
			MethodName: "SetOutput",
			Handler:    _CameraCoreService_SetOutput_Handler,
		},
		{
			MethodName: "SetEncode",
			Handler:    _CameraCoreService_SetEncode_Handler,
		},
		{
			MethodName: "SetQuality",
			Handler:    _CameraCoreService_SetQuality_Handler,
		},
		{
			MethodName: "SetPicture",
			Handler:    _CameraCoreService_SetPicture_Handler,
		},
		{
			MethodName: "ResetPicture",
			Handler:    _CameraCoreService_ResetPicture_Handler,
		},
		{
			MethodName: "SetCurve",
			Handler:    _CameraCoreService_SetCurve_Handler,
		},
		{
			MethodName: "SetStorage",
			Handler:    _CameraCoreService_SetStorage_Handler,
		},
		{
			MethodName: "SetHDR",
			Handler:    _CameraCoreService_SetHDR_Handler,
		},
		{
			MethodName: "SetFOV",
			Handler:    _CameraCoreService_SetFOV_Handler,
		},
		{
			MethodName: "SetSoftware",
			Handler:    _CameraCoreService_SetSoftware_Handler,
		},
		{
			MethodName: "Calibrate",
			Handler:    _CameraCoreService_Calibrate_Handler,
		},
		{
			MethodName: "GetCalibrations",
			Handler:    _CameraCoreService_GetCalibrations_Handler,
		},
		{
			MethodName: "SetCalibration",
			Handler:    _CameraCoreService_SetCalibration_Handler,
		},
		{
			MethodName: "SetDefaultCalibration",
			Handler:    _CameraCoreService_SetDefaultCalibration_Handler,
		},
		{
			MethodName: "SaveCalibration",
			Handler:    _CameraCoreService_SaveCalibration_Handler,
		},
		{
			MethodName: "GetAudioDevices",
			Handler:    _CameraCoreService_GetAudioDevices_Handler,
		},
		{
			MethodName: "SetAudioDevice",
			Handler:    _CameraCoreService_SetAudioDevice_Handler,
		},
		{
			MethodName: "Mount",
			Handler:    _CameraCoreService_Mount_Handler,
		},
		{
			MethodName: "Unmount",
			Handler:    _CameraCoreService_Unmount_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _CameraCoreService_Shutdown_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "NotificationStreaming",
			Handler:       _CameraCoreService_NotificationStreaming_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "camera_core.proto",
}

func (m *RTMPPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RTMPPoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RtmpAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(len(m.RtmpAddress)))
		i += copy(dAtA[i:], m.RtmpAddress)
	}
	if len(m.RtmpsAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(len(m.RtmpsAddress)))
		i += copy(dAtA[i:], m.RtmpsAddress)
	}
	return i, nil
}

func (m *Preview) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Preview) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *Output) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Output) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Type))
	}
	if m.Primary != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Primary.Size()))
		n1, err := m.Primary.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Secondary != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Secondary.Size()))
		n2, err := m.Secondary.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.StartTimestamp != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.StartTimestamp))
	}
	return i, nil
}

func (m *Encode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Encode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Framerate != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Framerate))
	}
	if m.Bitrate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Bitrate))
	}
	return i, nil
}

func (m *Quality) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Quality) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *Point) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Point) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64CameraCore(dAtA, i, uint64(math.Float64bits(float64(m.X))))
	}
	if m.Y != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64CameraCore(dAtA, i, uint64(math.Float64bits(float64(m.Y))))
	}
	return i, nil
}

func (m *Picture) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Picture) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exposure != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64CameraCore(dAtA, i, uint64(math.Float64bits(float64(m.Exposure))))
	}
	if m.Shadows != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64CameraCore(dAtA, i, uint64(math.Float64bits(float64(m.Shadows))))
	}
	if m.Temperature != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64CameraCore(dAtA, i, uint64(math.Float64bits(float64(m.Temperature))))
	}
	if m.Tint != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64CameraCore(dAtA, i, uint64(math.Float64bits(float64(m.Tint))))
	}
	if m.Saturation != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64CameraCore(dAtA, i, uint64(math.Float64bits(float64(m.Saturation))))
	}
	return i, nil
}

func (m *Curve) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Curve) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(len(m.Values)*8))
		for _, num := range m.Values {
			f3 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f3)
			i++
			dAtA[i] = uint8(f3 >> 8)
			i++
			dAtA[i] = uint8(f3 >> 16)
			i++
			dAtA[i] = uint8(f3 >> 24)
			i++
			dAtA[i] = uint8(f3 >> 32)
			i++
			dAtA[i] = uint8(f3 >> 40)
			i++
			dAtA[i] = uint8(f3 >> 48)
			i++
			dAtA[i] = uint8(f3 >> 56)
			i++
		}
	}
	if len(m.Cps) > 0 {
		for _, msg := range m.Cps {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCameraCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Notification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notification) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Timestamp))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *AudioDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudioDevice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *AudioDevices) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudioDevices) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCameraCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ActiveIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.ActiveIndex))
	}
	return i, nil
}

func (m *Calibration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Calibration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *Calibrations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Calibrations) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Calibrations) > 0 {
		for _, msg := range m.Calibrations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCameraCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ActiveIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.ActiveIndex))
	}
	return i, nil
}

func (m *HDR) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HDR) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *Storage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Storage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsMounted {
		dAtA[i] = 0x8
		i++
		if m.IsMounted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Total != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Total))
	}
	if m.Used != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Used))
	}
	return i, nil
}

func (m *WifiNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WifiNetwork) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ssid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(len(m.Ssid)))
		i += copy(dAtA[i:], m.Ssid)
	}
	if len(m.Signal) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(len(m.Signal)))
		i += copy(dAtA[i:], m.Signal)
	}
	if len(m.Security) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(len(m.Security)))
		i += copy(dAtA[i:], m.Security)
	}
	if m.IsActive {
		dAtA[i] = 0x20
		i++
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Network) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EthConnected {
		dAtA[i] = 0x8
		i++
		if m.EthConnected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.WifiNetworks) > 0 {
		for _, msg := range m.WifiNetworks {
			dAtA[i] = 0x22
			i++
			i = encodeVarintCameraCore(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Software) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Software) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Installed) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(len(m.Installed)))
		i += copy(dAtA[i:], m.Installed)
	}
	if len(m.Candidate) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(len(m.Candidate)))
		i += copy(dAtA[i:], m.Candidate)
	}
	return i, nil
}

func (m *FOV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FOV) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Mode))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Offset))
	}
	return i, nil
}

func (m *State) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *State) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Preview != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Preview.Size()))
		n4, err := m.Preview.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Output != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Output.Size()))
		n5, err := m.Output.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Encode != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Encode.Size()))
		n6, err := m.Encode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Picture != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Picture.Size()))
		n7, err := m.Picture.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Curve != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Curve.Size()))
		n8, err := m.Curve.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Notification != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Notification.Size()))
		n9, err := m.Notification.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Hdr != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Hdr.Size()))
		n10, err := m.Hdr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Storage != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Storage.Size()))
		n11, err := m.Storage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Network != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Network.Size()))
		n12, err := m.Network.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.AudioDevices != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.AudioDevices.Size()))
		n13, err := m.AudioDevices.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Software != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Software.Size()))
		n14, err := m.Software.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Calibrations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Calibrations.Size()))
		n15, err := m.Calibrations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Fov != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Fov.Size()))
		n16, err := m.Fov.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Quality != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCameraCore(dAtA, i, uint64(m.Quality.Size()))
		n17, err := m.Quality.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func encodeFixed64CameraCore(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32CameraCore(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCameraCore(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RTMPPoint) Size() (n int) {
	var l int
	_ = l
	l = len(m.RtmpAddress)
	if l > 0 {
		n += 1 + l + sovCameraCore(uint64(l))
	}
	l = len(m.RtmpsAddress)
	if l > 0 {
		n += 1 + l + sovCameraCore(uint64(l))
	}
	return n
}

func (m *Preview) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCameraCore(uint64(m.Type))
	}
	return n
}

func (m *Output) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCameraCore(uint64(m.Type))
	}
	if m.Primary != nil {
		l = m.Primary.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Secondary != nil {
		l = m.Secondary.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.StartTimestamp != 0 {
		n += 1 + sovCameraCore(uint64(m.StartTimestamp))
	}
	return n
}

func (m *Encode) Size() (n int) {
	var l int
	_ = l
	if m.Framerate != 0 {
		n += 1 + sovCameraCore(uint64(m.Framerate))
	}
	if m.Bitrate != 0 {
		n += 1 + sovCameraCore(uint64(m.Bitrate))
	}
	return n
}

func (m *Quality) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCameraCore(uint64(m.Type))
	}
	return n
}

func (m *Point) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 9
	}
	if m.Y != 0 {
		n += 9
	}
	return n
}

func (m *Picture) Size() (n int) {
	var l int
	_ = l
	if m.Exposure != 0 {
		n += 9
	}
	if m.Shadows != 0 {
		n += 9
	}
	if m.Temperature != 0 {
		n += 9
	}
	if m.Tint != 0 {
		n += 9
	}
	if m.Saturation != 0 {
		n += 9
	}
	return n
}

func (m *Curve) Size() (n int) {
	var l int
	_ = l
	if len(m.Values) > 0 {
		n += 1 + sovCameraCore(uint64(len(m.Values)*8)) + len(m.Values)*8
	}
	if len(m.Cps) > 0 {
		for _, e := range m.Cps {
			l = e.Size()
			n += 1 + l + sovCameraCore(uint64(l))
		}
	}
	return n
}

func (m *Notification) Size() (n int) {
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovCameraCore(uint64(m.Timestamp))
	}
	if m.Type != 0 {
		n += 1 + sovCameraCore(uint64(m.Type))
	}
	return n
}

func (m *AudioDevice) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCameraCore(uint64(l))
	}
	return n
}

func (m *AudioDevices) Size() (n int) {
	var l int
	_ = l
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovCameraCore(uint64(l))
		}
	}
	if m.ActiveIndex != 0 {
		n += 1 + sovCameraCore(uint64(m.ActiveIndex))
	}
	return n
}

func (m *Calibration) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCameraCore(uint64(l))
	}
	return n
}

func (m *Calibrations) Size() (n int) {
	var l int
	_ = l
	if len(m.Calibrations) > 0 {
		for _, e := range m.Calibrations {
			l = e.Size()
			n += 1 + l + sovCameraCore(uint64(l))
		}
	}
	if m.ActiveIndex != 0 {
		n += 1 + sovCameraCore(uint64(m.ActiveIndex))
	}
	return n
}

func (m *HDR) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovCameraCore(uint64(m.Type))
	}
	return n
}

func (m *Storage) Size() (n int) {
	var l int
	_ = l
	if m.IsMounted {
		n += 2
	}
	if m.Total != 0 {
		n += 1 + sovCameraCore(uint64(m.Total))
	}
	if m.Used != 0 {
		n += 1 + sovCameraCore(uint64(m.Used))
	}
	return n
}

func (m *WifiNetwork) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ssid)
	if l > 0 {
		n += 1 + l + sovCameraCore(uint64(l))
	}
	l = len(m.Signal)
	if l > 0 {
		n += 1 + l + sovCameraCore(uint64(l))
	}
	l = len(m.Security)
	if l > 0 {
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.IsActive {
		n += 2
	}
	return n
}

func (m *Network) Size() (n int) {
	var l int
	_ = l
	if m.EthConnected {
		n += 2
	}
	if len(m.WifiNetworks) > 0 {
		for _, e := range m.WifiNetworks {
			l = e.Size()
			n += 1 + l + sovCameraCore(uint64(l))
		}
	}
	return n
}

func (m *Software) Size() (n int) {
	var l int
	_ = l
	l = len(m.Installed)
	if l > 0 {
		n += 1 + l + sovCameraCore(uint64(l))
	}
	l = len(m.Candidate)
	if l > 0 {
		n += 1 + l + sovCameraCore(uint64(l))
	}
	return n
}

func (m *FOV) Size() (n int) {
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovCameraCore(uint64(m.Mode))
	}
	if m.Offset != 0 {
		n += 1 + sovCameraCore(uint64(m.Offset))
	}
	return n
}

func (m *State) Size() (n int) {
	var l int
	_ = l
	if m.Preview != nil {
		l = m.Preview.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Encode != nil {
		l = m.Encode.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Picture != nil {
		l = m.Picture.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Curve != nil {
		l = m.Curve.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Notification != nil {
		l = m.Notification.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Hdr != nil {
		l = m.Hdr.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Storage != nil {
		l = m.Storage.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Network != nil {
		l = m.Network.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.AudioDevices != nil {
		l = m.AudioDevices.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Software != nil {
		l = m.Software.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Calibrations != nil {
		l = m.Calibrations.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Fov != nil {
		l = m.Fov.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	if m.Quality != nil {
		l = m.Quality.Size()
		n += 1 + l + sovCameraCore(uint64(l))
	}
	return n
}

func sovCameraCore(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCameraCore(x uint64) (n int) {
	return sovCameraCore(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RTMPPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RTMPPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RTMPPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtmpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RtmpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtmpsAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RtmpsAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Preview) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Preview: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Preview: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Preview_PreviewType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Output) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Output: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Output: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Output_OutputType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Primary == nil {
				m.Primary = &RTMPPoint{}
			}
			if err := m.Primary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secondary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secondary == nil {
				m.Secondary = &RTMPPoint{}
			}
			if err := m.Secondary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			m.StartTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Encode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Encode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Encode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Framerate", wireType)
			}
			m.Framerate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Framerate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitrate", wireType)
			}
			m.Bitrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bitrate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Quality) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Quality: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Quality: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Quality_QualityType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Point) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Point: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Point: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.X = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Y = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Picture) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Picture: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Picture: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exposure", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Exposure = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shadows", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Shadows = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Temperature = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tint", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Tint = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Saturation", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Saturation = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Curve) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Curve: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Curve: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Values = append(m.Values, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCameraCore
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCameraCore
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Values = append(m.Values, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cps = append(m.Cps, &Point{})
			if err := m.Cps[len(m.Cps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Notification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (Notification_NotificationType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudioDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudioDevices) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioDevices: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioDevices: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &AudioDevice{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveIndex", wireType)
			}
			m.ActiveIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Calibration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Calibration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Calibration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Calibrations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Calibrations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Calibrations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calibrations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Calibrations = append(m.Calibrations, &Calibration{})
			if err := m.Calibrations[len(m.Calibrations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveIndex", wireType)
			}
			m.ActiveIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HDR) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HDR: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HDR: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (HDR_HDRType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Storage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Storage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Storage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMounted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMounted = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WifiNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WifiNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WifiNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ssid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ssid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Security = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Network) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Network: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Network: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthConnected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EthConnected = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WifiNetworks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WifiNetworks = append(m.WifiNetworks, &WifiNetwork{})
			if err := m.WifiNetworks[len(m.WifiNetworks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Software) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Software: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Software: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Installed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Installed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Candidate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Candidate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FOV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FOV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FOV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (FOV_FOVMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *State) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: State: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Preview == nil {
				m.Preview = &Preview{}
			}
			if err := m.Preview.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &Output{}
			}
			if err := m.Output.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encode == nil {
				m.Encode = &Encode{}
			}
			if err := m.Encode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Picture", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Picture == nil {
				m.Picture = &Picture{}
			}
			if err := m.Picture.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Curve", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Curve == nil {
				m.Curve = &Curve{}
			}
			if err := m.Curve.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notification", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Notification == nil {
				m.Notification = &Notification{}
			}
			if err := m.Notification.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hdr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hdr == nil {
				m.Hdr = &HDR{}
			}
			if err := m.Hdr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Storage == nil {
				m.Storage = &Storage{}
			}
			if err := m.Storage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Network == nil {
				m.Network = &Network{}
			}
			if err := m.Network.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AudioDevices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AudioDevices == nil {
				m.AudioDevices = &AudioDevices{}
			}
			if err := m.AudioDevices.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Software", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Software == nil {
				m.Software = &Software{}
			}
			if err := m.Software.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calibrations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Calibrations == nil {
				m.Calibrations = &Calibrations{}
			}
			if err := m.Calibrations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fov", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fov == nil {
				m.Fov = &FOV{}
			}
			if err := m.Fov.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCameraCore
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Quality == nil {
				m.Quality = &Quality{}
			}
			if err := m.Quality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCameraCore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCameraCore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCameraCore(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCameraCore
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCameraCore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCameraCore
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCameraCore
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCameraCore(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCameraCore = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCameraCore   = fmt.Errorf("proto: integer overflow")
)

func init() { proto1.RegisterFile("camera_core.proto", fileDescriptorCameraCore) }

var fileDescriptorCameraCore = []byte{
	// 1638 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xdd, 0x6e, 0xdb, 0xca,
	0x11, 0x16, 0x45, 0x49, 0x94, 0x46, 0xb2, 0xcd, 0xb3, 0xe9, 0x49, 0x55, 0x9d, 0x1c, 0x23, 0x65,
	0x4e, 0x5b, 0xa3, 0x49, 0x94, 0xc4, 0x01, 0x12, 0x17, 0xfd, 0x49, 0x14, 0xfd, 0x58, 0x2a, 0x2c,
	0xd1, 0x5d, 0x4a, 0x36, 0xd0, 0x1b, 0x82, 0x16, 0x57, 0xf6, 0xa2, 0x12, 0xa9, 0x92, 0x2b, 0xff,
	0x00, 0xbd, 0xe8, 0x2b, 0xf4, 0xa2, 0x40, 0x9f, 0xa2, 0x40, 0xdf, 0xa2, 0x97, 0x7d, 0x84, 0x20,
	0x7d, 0x91, 0x62, 0x97, 0x4b, 0x91, 0x54, 0xec, 0x24, 0xcd, 0x85, 0xc0, 0x9d, 0x99, 0x6f, 0x77,
	0x66, 0xe7, 0x6f, 0x47, 0xf0, 0xcd, 0xd4, 0x59, 0x90, 0xc0, 0xb1, 0xa7, 0x7e, 0x40, 0x9a, 0xcb,
	0xc0, 0x67, 0x3e, 0x2a, 0x8a, 0x4f, 0xe3, 0xbb, 0x73, 0xdf, 0x3f, 0x9f, 0x93, 0x67, 0x82, 0x3a,
	0x5b, 0xcd, 0x9e, 0x91, 0xc5, 0x92, 0xdd, 0x44, 0x18, 0xc3, 0x82, 0x0a, 0x1e, 0x0f, 0x8f, 0x8f,
	0x7d, 0xea, 0x31, 0xf4, 0x53, 0xa8, 0x05, 0x6c, 0xb1, 0xb4, 0x1d, 0xd7, 0x0d, 0x48, 0x18, 0xd6,
	0x95, 0x87, 0xca, 0x5e, 0x05, 0x57, 0x39, 0xaf, 0x15, 0xb1, 0xd0, 0x23, 0xd8, 0xe2, 0x64, 0xb8,
	0xc6, 0xe4, 0x05, 0x46, 0xec, 0x0b, 0x25, 0xc8, 0xb8, 0x00, 0xed, 0x38, 0x20, 0x97, 0x94, 0x5c,
	0xa1, 0x26, 0x14, 0xd8, 0xcd, 0x92, 0x88, 0xa3, 0xb6, 0xf7, 0x1b, 0x91, 0xd6, 0xa6, 0x94, 0xc6,
	0xdf, 0xf1, 0xcd, 0x92, 0x60, 0x81, 0x33, 0x9e, 0x42, 0x35, 0xc5, 0x44, 0x65, 0x28, 0x8c, 0xcc,
	0x51, 0x57, 0xcf, 0x21, 0x80, 0x92, 0x35, 0xee, 0xe2, 0xae, 0xa9, 0x2b, 0x9c, 0x3b, 0x34, 0x47,
	0xa6, 0x9e, 0x37, 0xfe, 0x9a, 0x87, 0x92, 0xb9, 0x62, 0xcb, 0x15, 0x43, 0x4f, 0x32, 0x9a, 0xea,
	0x52, 0x53, 0x24, 0x94, 0x9f, 0x44, 0x0f, 0xfa, 0x25, 0x68, 0xcb, 0x80, 0x2e, 0x9c, 0xe0, 0x46,
	0xdc, 0xa0, 0xba, 0xaf, 0xcb, 0x0d, 0x6b, 0x6f, 0xe0, 0x18, 0x80, 0x9a, 0x50, 0x09, 0xc9, 0xd4,
	0xf7, 0x5c, 0x8e, 0x56, 0xef, 0x40, 0x27, 0x10, 0xf4, 0x0b, 0xd8, 0x09, 0x99, 0x13, 0x30, 0x9b,
	0xd1, 0x05, 0x09, 0x99, 0xb3, 0x58, 0xd6, 0xcb, 0x0f, 0x95, 0x3d, 0x15, 0x6f, 0x0b, 0xf6, 0x38,
	0xe6, 0x1a, 0x6d, 0x80, 0xc4, 0x30, 0xa4, 0x81, 0x6a, 0xf6, 0x7a, 0x7a, 0x8e, 0x2f, 0xfa, 0x47,
	0x56, 0x74, 0xcf, 0xde, 0xe0, 0xa8, 0xab, 0xe7, 0xf9, 0x8a, 0xab, 0xd2, 0x55, 0xb4, 0x03, 0x55,
	0xbe, 0xb2, 0xdb, 0x13, 0x6b, 0x6c, 0x0e, 0xf5, 0x82, 0xf1, 0x16, 0x4a, 0x5d, 0x6f, 0xea, 0xbb,
	0x04, 0x3d, 0x80, 0xca, 0x2c, 0x10, 0x59, 0xc0, 0x22, 0x37, 0x6c, 0xe1, 0x84, 0x81, 0xea, 0xa0,
	0x9d, 0x51, 0x26, 0x64, 0x79, 0x21, 0x8b, 0x49, 0xe3, 0x2f, 0xa0, 0xfd, 0x61, 0xe5, 0xcc, 0x29,
	0xbb, 0xb9, 0x23, 0x5c, 0x52, 0x1a, 0x7f, 0x53, 0xe1, 0x6a, 0x41, 0x35, 0xc5, 0x4c, 0x85, 0x4b,
	0x03, 0xf5, 0xc8, 0x3c, 0xd5, 0x15, 0x1e, 0xb7, 0x61, 0xb7, 0x33, 0x98, 0x0c, 0xa3, 0x5b, 0xf4,
	0x07, 0x87, 0x7d, 0x5d, 0x45, 0x15, 0x28, 0x4e, 0x8e, 0xc6, 0xb8, 0xa5, 0x17, 0x8c, 0x47, 0x50,
	0x8c, 0xb2, 0xaf, 0x06, 0xca, 0xb5, 0x50, 0xac, 0x60, 0xe5, 0x9a, 0x53, 0x51, 0x68, 0x14, 0xac,
	0xdc, 0x18, 0x7f, 0x57, 0x40, 0x3b, 0xa6, 0x53, 0xb6, 0x0a, 0x08, 0x6a, 0x40, 0x99, 0x5c, 0x2f,
	0xfd, 0x70, 0x15, 0x10, 0x09, 0x5f, 0xd3, 0xfc, 0x92, 0xe1, 0x85, 0xe3, 0xfa, 0x57, 0xa1, 0xdc,
	0x1b, 0x93, 0xe8, 0x21, 0x54, 0x19, 0x59, 0x2c, 0xb9, 0x2f, 0xf8, 0x46, 0x55, 0x48, 0xd3, 0x2c,
	0x84, 0xa0, 0xc0, 0xa8, 0xc7, 0xea, 0x05, 0x21, 0x12, 0x6b, 0xb4, 0x0b, 0x10, 0x72, 0xa9, 0xc3,
	0xa8, 0xef, 0xd5, 0x8b, 0x42, 0x92, 0xe2, 0x18, 0x6f, 0xa0, 0xd8, 0x5e, 0x05, 0x97, 0x04, 0xdd,
	0x87, 0xd2, 0xa5, 0x33, 0x5f, 0x11, 0x5e, 0x34, 0xea, 0x9e, 0x82, 0x25, 0x85, 0x76, 0x41, 0x9d,
	0x2e, 0xb9, 0x31, 0xea, 0x5e, 0x75, 0xbf, 0x16, 0xa7, 0xbf, 0xc8, 0x18, 0x2e, 0x30, 0xfe, 0x99,
	0x87, 0xda, 0xc8, 0x67, 0x74, 0x46, 0xa7, 0xe2, 0x44, 0x61, 0x05, 0xb9, 0x66, 0xb2, 0xf6, 0xc4,
	0x9a, 0x07, 0x36, 0x49, 0xa5, 0x28, 0x78, 0x09, 0x03, 0x1d, 0xc8, 0x98, 0xa9, 0x22, 0x66, 0x3f,
	0x48, 0x1d, 0xe9, 0x43, 0x33, 0x44, 0x2a, 0x7a, 0xff, 0x52, 0x40, 0xdf, 0x14, 0xa5, 0x62, 0x58,
	0x05, 0xcd, 0x9a, 0xb4, 0xdb, 0x5d, 0x8b, 0xe7, 0x62, 0x05, 0x8a, 0x5d, 0x8c, 0x4d, 0xac, 0xe7,
	0x39, 0xff, 0xb4, 0x85, 0x47, 0x83, 0xd1, 0xa1, 0xae, 0xa2, 0x1f, 0xc3, 0xbd, 0x76, 0xeb, 0x68,
	0xf0, 0x0e, 0xb7, 0xc6, 0x03, 0x73, 0x64, 0xc7, 0x1b, 0x0a, 0xe8, 0x3e, 0xa0, 0xb4, 0xa0, 0xd7,
	0x1a, 0x1c, 0x75, 0x3b, 0x7a, 0x11, 0xe9, 0x50, 0x6b, 0x4d, 0x3a, 0x03, 0xd3, 0x6e, 0xf7, 0x5b,
	0xa3, 0xc3, 0xae, 0x5e, 0xe2, 0xc8, 0x77, 0x93, 0xf1, 0xd8, 0x1c, 0xd9, 0xb8, 0xdb, 0x36, 0x71,
	0xc7, 0x16, 0x49, 0xaf, 0xa1, 0x7b, 0xb0, 0x23, 0xf9, 0x56, 0x7f, 0x32, 0xee, 0x98, 0xa7, 0x23,
	0xbd, 0x6c, 0x7c, 0x0f, 0xd5, 0xd6, 0xca, 0xa5, 0x7e, 0x87, 0x5c, 0xd2, 0x29, 0x41, 0xdb, 0x90,
	0xa7, 0xae, 0x74, 0x56, 0x9e, 0xba, 0x86, 0x0d, 0xb5, 0x94, 0x38, 0x44, 0x4f, 0x40, 0x73, 0xa3,
	0xa5, 0x08, 0x4c, 0x75, 0x1f, 0x49, 0xff, 0xa4, 0x50, 0x38, 0x86, 0xf0, 0x06, 0xe8, 0x4c, 0x19,
	0xbd, 0x24, 0x36, 0xf5, 0x5c, 0x72, 0x2d, 0x7d, 0x5d, 0x8d, 0x78, 0x03, 0xce, 0xe2, 0xfa, 0xdb,
	0xce, 0x9c, 0x9e, 0x45, 0x09, 0xf0, 0x91, 0x7e, 0x0a, 0xb5, 0x94, 0x38, 0x44, 0xaf, 0xa0, 0x36,
	0x4d, 0xd1, 0x1b, 0x46, 0xa4, 0xa0, 0x38, 0x83, 0xfb, 0x12, 0x4b, 0x2c, 0x50, 0xfb, 0x1d, 0x8c,
	0x7e, 0x9e, 0x29, 0xd9, 0xf8, 0xe4, 0x7e, 0x07, 0xf3, 0x5f, 0x2a, 0xd8, 0x3f, 0x80, 0x26, 0x19,
	0x49, 0xa7, 0x29, 0x41, 0xde, 0x1c, 0x45, 0x8d, 0xa6, 0x35, 0x19, 0xf3, 0x86, 0x8a, 0x41, 0xb3,
	0x98, 0x1f, 0x38, 0xe7, 0x04, 0x7d, 0x0f, 0x40, 0x43, 0x7b, 0xe1, 0xaf, 0x3c, 0x46, 0xa2, 0x2b,
	0x96, 0x71, 0x85, 0x86, 0xc3, 0x88, 0x81, 0x7e, 0x04, 0x45, 0xe6, 0x33, 0x67, 0x2e, 0x4c, 0x2b,
	0xe0, 0x88, 0xe0, 0xe9, 0xbb, 0x0a, 0x89, 0x2b, 0x92, 0xb1, 0x80, 0xc5, 0xda, 0x08, 0xa0, 0x7a,
	0x4a, 0x67, 0x74, 0x44, 0xd8, 0x95, 0x1f, 0xfc, 0x89, 0x43, 0xc2, 0x70, 0xed, 0x34, 0xb1, 0xe6,
	0xe5, 0x13, 0xd2, 0x73, 0x4f, 0x9e, 0x56, 0xc1, 0x92, 0xe2, 0xb5, 0x1e, 0x92, 0xe9, 0x2a, 0xa0,
	0x2c, 0xea, 0xbc, 0x15, 0xbc, 0xa6, 0xd1, 0x77, 0x50, 0xa1, 0xa1, 0x1d, 0x79, 0x44, 0x14, 0x6d,
	0x19, 0x97, 0x69, 0xd8, 0x12, 0xb4, 0x71, 0x0e, 0x5a, 0xac, 0xef, 0x11, 0x6c, 0x11, 0x76, 0x61,
	0x4f, 0x7d, 0xcf, 0x23, 0xd3, 0xe4, 0x2a, 0x35, 0xc2, 0x2e, 0xda, 0x31, 0x0f, 0xbd, 0x86, 0xad,
	0x2b, 0x3a, 0xa3, 0xb6, 0x17, 0x6d, 0x0a, 0xeb, 0x85, 0x4c, 0xa0, 0x52, 0xf6, 0xe3, 0xda, 0x55,
	0x42, 0x84, 0x46, 0x0f, 0xca, 0x96, 0x3f, 0x63, 0x57, 0x4e, 0x20, 0x1a, 0x30, 0xf5, 0x42, 0xe6,
	0xcc, 0xe7, 0x24, 0xbe, 0x5e, 0xc2, 0xe0, 0xd2, 0xa9, 0xe3, 0xb9, 0xd4, 0x8d, 0x5b, 0x70, 0x05,
	0x27, 0x0c, 0x83, 0x81, 0xda, 0x33, 0x4f, 0x78, 0x34, 0x17, 0xbe, 0xbb, 0x19, 0xcd, 0x9e, 0x79,
	0xc2, 0x7f, 0x43, 0xdf, 0x25, 0x58, 0xc8, 0xb9, 0xc3, 0xfc, 0xd9, 0x2c, 0x24, 0x4c, 0x66, 0x86,
	0xa4, 0x8c, 0xa7, 0xa0, 0x49, 0x20, 0x2f, 0xb4, 0x9e, 0x79, 0x62, 0x0f, 0xcd, 0x4e, 0xd7, 0x7e,
	0xf9, 0xea, 0xb9, 0x9e, 0xcb, 0x70, 0x5e, 0x1c, 0x3c, 0xd7, 0x15, 0xe3, 0x7d, 0x01, 0x8a, 0x16,
	0xe3, 0xcf, 0xc3, 0x1e, 0x7f, 0x10, 0xc5, 0xc3, 0x2b, 0x74, 0x57, 0xf7, 0xb7, 0xb3, 0x6f, 0x35,
	0x8e, 0xc5, 0xe8, 0x67, 0x50, 0xf2, 0xc5, 0xab, 0x25, 0x5f, 0xce, 0xad, 0xcc, 0x53, 0x8b, 0xa5,
	0x90, 0xc3, 0x88, 0x78, 0x97, 0xe4, 0x93, 0x19, 0xc3, 0xa2, 0xc7, 0x0a, 0x4b, 0xa1, 0xd0, 0x1b,
	0x35, 0x76, 0x11, 0xc3, 0x94, 0xde, 0x88, 0x8b, 0x63, 0x31, 0x32, 0xa0, 0x38, 0xe5, 0xbd, 0x56,
	0xb4, 0xe1, 0xa4, 0x99, 0x8a, 0xfe, 0x8b, 0x23, 0x11, 0x7a, 0x0d, 0x35, 0x2f, 0xd5, 0xd0, 0xea,
	0x25, 0x01, 0xbd, 0x77, 0x4b, 0x4f, 0xc4, 0x19, 0x20, 0x7a, 0x00, 0xea, 0x85, 0x1b, 0xd4, 0x35,
	0x81, 0x87, 0xa4, 0x88, 0x30, 0x67, 0x73, 0x23, 0xc3, 0xa8, 0x2a, 0xc4, 0x4b, 0x9e, 0x18, 0x29,
	0x6b, 0x05, 0xc7, 0x62, 0x8e, 0x94, 0x29, 0x54, 0xaf, 0x64, 0x90, 0x71, 0xf6, 0xc4, 0x62, 0x74,
	0x00, 0x5b, 0x0e, 0xef, 0x41, 0x76, 0xdc, 0x9f, 0x20, 0x63, 0x6b, 0xba, 0x8b, 0xe1, 0x9a, 0x93,
	0xee, 0x69, 0x8f, 0xa1, 0x1c, 0xca, 0x94, 0xab, 0x57, 0xc5, 0xa6, 0x9d, 0xd8, 0x1c, 0xc9, 0xc6,
	0x6b, 0x00, 0xf7, 0x48, 0xa6, 0x01, 0xd5, 0x32, 0x5a, 0xd2, 0xbd, 0x6a, 0xa3, 0x03, 0x3d, 0x00,
	0x75, 0xe6, 0x5f, 0xd6, 0xb7, 0x32, 0x1e, 0xe9, 0x99, 0x27, 0x98, 0xb3, 0xf9, 0x3d, 0xff, 0x1c,
	0x3d, 0xfc, 0xf5, 0xed, 0xcc, 0x3d, 0xe5, 0x38, 0x80, 0x63, 0xf1, 0xfe, 0xdf, 0x00, 0xbe, 0x69,
	0x8b, 0x21, 0xa4, 0xed, 0x07, 0xc4, 0x22, 0x81, 0xe8, 0xdb, 0xfb, 0x50, 0x3e, 0x24, 0x2c, 0x4a,
	0xbd, 0xfb, 0xcd, 0x68, 0x42, 0x6d, 0xc6, 0x13, 0x6a, 0xb3, 0xcb, 0x27, 0xd4, 0x46, 0x6d, 0xed,
	0x64, 0x5e, 0x20, 0x39, 0xd4, 0x04, 0xb0, 0x08, 0x8b, 0x27, 0xcb, 0x8d, 0xfc, 0x6c, 0x6c, 0xd0,
	0x46, 0x0e, 0x3d, 0x86, 0x8a, 0x45, 0x98, 0x1c, 0x0f, 0xb3, 0x59, 0xda, 0xc8, 0x92, 0x6b, 0xb0,
	0x9c, 0xa4, 0xb2, 0xb9, 0xda, 0xc8, 0x92, 0x6b, 0x4b, 0xe2, 0xa1, 0x69, 0xe3, 0xea, 0x8d, 0x0d,
	0x3a, 0xb1, 0x5c, 0x26, 0xf2, 0x46, 0x86, 0x37, 0x36, 0x68, 0x23, 0x87, 0x0e, 0xa0, 0x86, 0x49,
	0x98, 0xec, 0xb8, 0xcb, 0x43, 0x1f, 0xef, 0xdc, 0x83, 0xb2, 0x45, 0x58, 0x34, 0x93, 0x64, 0x2a,
	0xa4, 0x91, 0xa1, 0xd6, 0x36, 0xc5, 0xcd, 0x7e, 0x23, 0xa1, 0x1b, 0x1b, 0xb4, 0x91, 0x43, 0x06,
	0x94, 0x2c, 0xc2, 0xf8, 0x8b, 0x93, 0x2a, 0x8f, 0x46, 0x6a, 0xbd, 0xc6, 0xf0, 0x3e, 0x96, 0x4a,
	0x98, 0x46, 0x6a, 0x6d, 0xe4, 0xd0, 0x0b, 0xa8, 0x72, 0xbd, 0x71, 0x7e, 0x6e, 0xa6, 0x6e, 0x63,
	0x93, 0x61, 0xe4, 0xd0, 0xef, 0xe1, 0xdb, 0x74, 0xe9, 0x5a, 0x2c, 0x20, 0xce, 0x82, 0x7a, 0xe7,
	0x77, 0xfa, 0xe5, 0xb6, 0x82, 0x37, 0x72, 0x7b, 0xca, 0x73, 0x05, 0xfd, 0x16, 0x2a, 0x71, 0xd2,
	0xdf, 0xed, 0xd7, 0x3b, 0xf8, 0x46, 0x0e, 0xbd, 0x85, 0x9d, 0x43, 0xc2, 0x32, 0x4f, 0xfc, 0xe7,
	0x8c, 0x48, 0x83, 0x8d, 0x1c, 0xfa, 0x1d, 0x6c, 0x5b, 0x99, 0x13, 0xd0, 0x2d, 0xd3, 0xc0, 0x27,
	0x2c, 0x18, 0xc0, 0xb7, 0x16, 0x61, 0x1d, 0x32, 0x73, 0x56, 0xf3, 0xcc, 0x31, 0xff, 0xff, 0x65,
	0xde, 0xc0, 0x8e, 0xe5, 0x5c, 0x92, 0x2f, 0x39, 0xe4, 0x16, 0x1b, 0xd7, 0xde, 0xc8, 0x0c, 0x5c,
	0x9f, 0xf3, 0x46, 0x1a, 0xbc, 0xf6, 0x46, 0x7a, 0xa2, 0xbb, 0x65, 0x40, 0xfb, 0xc4, 0x15, 0x7e,
	0x05, 0x45, 0x31, 0x90, 0x7c, 0xc5, 0xed, 0x7f, 0x0d, 0xda, 0xc4, 0x5b, 0x7c, 0xe5, 0xe6, 0xdf,
	0x40, 0xd9, 0xba, 0x58, 0x31, 0xd7, 0xbf, 0xfa, 0x0a, 0xc7, 0xbf, 0xfb, 0xc9, 0xbf, 0x3f, 0xec,
	0x2a, 0xff, 0xf9, 0xb0, 0xab, 0xbc, 0xff, 0xb0, 0xab, 0xfc, 0xe3, 0xbf, 0xbb, 0xb9, 0xbe, 0xf2,
	0xc7, 0xe8, 0xdf, 0xfa, 0x59, 0x49, 0x7c, 0x5e, 0xfe, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x92, 0x55,
	0x95, 0xb2, 0xd0, 0x0f, 0x00, 0x00,
}
